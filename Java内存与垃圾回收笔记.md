# Java内存与垃圾回收笔记

## Java内存模型：

<img src="https://upload-images.jianshu.io/upload_images/10006199-a4108d8fb7810a71.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:47%;" />

上图为Java的内存模型，接下来讲讲这些模块是什么，有什么用：

### 程序计数器：

* 程序计数器是控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
* 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，所以在任何一个确定的时间，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此，每个线程有自己的程序计数器。

### 虚拟机栈：

* 线程私有的，生命周期与线程相同。
* 虚拟机栈是描述Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出入口等信息。
* 每一个方法被调用直到执行完毕的过程，就对应一个栈帧在虚拟机从入栈到出栈的过程。

### 本地方法栈：

* 与虚拟机栈非常相似，区别只有虚拟机栈为虚拟机执行的Java方法（字节码）提供服务，而本地方法栈为本地方法提供服务（Native）。

### Java堆：

* 是虚拟机所管理的内存中最大的一块。
* 被所有线程共享。
* 堆的唯一目的就是**存放对象实例**，Java中几乎所有对象实例都在这里分配内存。
* 堆是垃圾收集器管理的内存区域，也被称为GC堆。
* 所有线程共享的Java堆中，可以划分出多个线程私有的分配缓冲区，以提升对象分配的效率。

### 方法区：

* 是各个线程共享的内存区域。
* 用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

#### 运行时常量池：

* 是方法区的一部分。
* Class的常量池表存放在这里。

## 垃圾回收算法

### 什么是垃圾：

* 判断一个对象是否要“去死”：
  * 引用计数算法：有一个地方引用，+1，引用失效-1.会遇到循环引用问题（A、B相互引用对方）。
  * 可达性分析法：从GC Root作为起点，遍历他们所引用的对象，没被他们引用的就是不可达的，一个对象不可达，就不被再使用。
    * 一个不可达的对象一般不是非死不可的，它被认为不可引用时进行第一次标记，


### 分代收集理论：

* 弱分代假说：大多数对象都是朝生熄灭的。
* 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
* 根据以上两个假说，将对象分根据不同年龄分在不同的区域存。（分成新生代和老年代）
* 对象的跨代引用对于同代引用来说仅占极少数。

### 垃圾清除算法：

* 标记-清除法：

  * 标记所有需要回收的对象，统一回收。
  * 缺点：
    * 效率不稳定（新生代需要大量被标记）。
    * 碎片化问题，对象清除会生成大量的内存碎片，大量对象无法找到足够的连续内存而不得不提前出发另一次垃圾收集。

* 标记-复制法：

  * 把内存区域分成大小相等的两块，每次只用其中一块。，每次清除完了，就把其中一块的内容复制到另一块，只需要移动堆顶指针顺序分配即可。
  * 优点：
    * 简单、高效
  * 缺点：
    * 可用内存缩小一半
  * 优化：分配一块较大的eden和两块小的survival，每次垃圾收集将内容从eden和suivivor幸存的复制到另外survival，清理掉垃圾收集区域。

* 标记-整理法：

  * 清除后整理使其连续，不常用。